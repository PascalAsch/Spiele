<!DOCTYPE html>
<html lang="de" data-theme="light">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
  <title>Wizard Scoreboard – Touch Pro · © Pascal Asch</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <link rel="preconnect" href="https://fonts.googleapis.com"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;800;900&display=swap" rel="stylesheet">
  <style>
    :root{
      --bg-grad: radial-gradient(1200px 800px at 60% 10%, #a5b4fc 0%, #6366f1 60%, #0f172a 100%);
      --glass-bg: rgba(255,255,255,.9);
      --text:#0b1020; --muted:#334155; --accent:#6366f1; --accent2:#38bdf8;
      --row1:#e0f2fe; --row2:#eef2ff; --head1:#e0e7ff; --head2:#f1f5fd;
      --input-bg:#ffffff; --input-border:#c7d2fe; --input-text:#0b1020;
      --sidebar-w: 300px; --sidebar-w-collapsed: 72px;
      --seg-bg:#eef2ff; --seg-on:#fff; --seg-border:#c7d2fe;
    }
    [data-theme="dark"]{
      --bg-grad: radial-gradient(1200px 800px at 60% 10%, #0b122b 0%, #0a0f22 60%, #000 100%);
      --glass-bg: rgba(17,24,39,.78);
      --text:#e5e7eb; --muted:#94a3b8; --accent:#8b5cf6; --accent2:#22d3ee;
      --row1:#0b122b; --row2:#0e172d; --head1:#111827; --head2:#0b122b;
      --input-bg:#111827; --input-border:#334155; --input-text:#e5e7eb;
      --seg-bg:#0e172d; --seg-on:#111827; --seg-border:#334155;
    }
    html,body{height:100%}
    body{margin:0;font-family:'Inter',system-ui,Arial,sans-serif;background:var(--bg-grad);color:var(--text);overflow-x:hidden}

    /* Parallax layers */
    .plx{position:fixed;inset:-10vh -10vw;pointer-events:none;z-index:-1;filter:blur(30px);opacity:.45;transform:translate3d(0,0,0) scale(1.05);transition:opacity .6s ease}
    .plx.l1{background:radial-gradient(900px 600px at 10% 20%, #a5b4fc55, transparent 70%)}
    .plx.l2{background:radial-gradient(900px 600px at 80% 10%, #38bdf855, transparent 72%)}
    .plx.l3{background:radial-gradient(900px 600px at 50% 90%, #8b5cf655, transparent 72%)}
    [data-theme="dark"] .plx{opacity:.28}

    .glass{background:var(--glass-bg);backdrop-filter:blur(14px) saturate(1.05);border-radius:18px;box-shadow:0 10px 40px #0000003a}
    .btn{display:inline-flex;align-items:center;justify-content:center;border-radius:12px;padding:.85rem 1rem;font-weight:800}
    .btn-primary{background:linear-gradient(90deg,var(--accent),var(--accent2));color:#fff}
    .btn-muted{background:#e5e7eb}
    [data-theme="dark"] .btn-muted{background:#1f2937;color:#e5e7eb}
    .btn-danger{background:#ef4444;color:#fff}
    .table-head-1{background:var(--head1);color:var(--text);font-weight:900}
    .table-head-2{background:var(--head2);color:var(--muted)}
    .row-tip{background:var(--row1)}
    .row-res{background:var(--row2)}
    .input{background:var(--input-bg);border:1px solid var(--input-border);color:var(--input-text)}
    .sidebar{position:fixed;inset:0 auto 0 0;width:var(--sidebar-w);padding:14px;display:flex;flex-direction:column;gap:12px;transition:width .25s ease}
    .sidebar.collapsed{width:var(--sidebar-w-collapsed)}
    .content{margin-left:calc(var(--sidebar-w) + 16px);min-height:100vh;padding:14px;transition:margin-left .25s ease}
    .content.shifted{margin-left:calc(var(--sidebar-w-collapsed) + 16px)}
    .icon-label{margin-left:.5rem}
    .sidebar.collapsed .icon-label{display:none}
    @media (max-width: 900px){
      .sidebar{transform:translateX(-110%);box-shadow:none}
      .sidebar.open{transform:translateX(0);z-index:50}
      .content{margin-left:0}
      .content.shifted{margin-left:0}
      #mobileShade{display:none}
      .sidebar.open + #mobileShade{display:block;position:fixed;inset:0;background:rgba(0,0,0,.3);z-index:40}
    }
    #view-game .grid-2cols{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    @media (max-width: 1024px){ #view-game .grid-2cols{grid-template-columns:1fr} }
    .leftPanel{display:grid;grid-template-rows:auto 1fr auto;gap:12px;height:calc(100vh - 28px)}
    .rightPanel{height:calc(100vh - 28px);overflow:auto}
    #keypadWrap{position:sticky;bottom:env(safe-area-inset-bottom);z-index:10}
    .h-180{height:180px}
    .h-240{height:240px}
    #endView{z-index:99990}
    #saveDetail{z-index:99995}

    /* Segmented controls – responsive, same row */
    .seg{display:flex;flex-wrap:wrap;background:var(--seg-bg);border:1px solid var(--seg-border);border-radius:14px;padding:6px;gap:6px;min-width:0}
    .seg button{flex:1 1 140px;border-radius:10px;padding:.6rem .8rem;font-weight:700;color:var(--muted);background:transparent;border:1px solid transparent;white-space:nowrap}
    .seg button.active{background:var(--seg-on);color:var(--text);border:1px solid var(--seg-border)}

    .setup-opts{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:1rem;align-items:start}
    @media (max-width: 768px){ .setup-opts{grid-template-columns:1fr} }
    .minw0{min-width:0}

    /* Center warning toast */
    #toast{position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);z-index:99999;display:none}
    #toast .bubble{padding:1rem 1.2rem;border-radius:14px;font-weight:800;box-shadow:0 10px 30px #00000033}

    /* End overlay inner scroll */
    #endView .panel{display:flex;flex-direction:column}
    #endScroll{overflow:auto;max-height:50vh}
  </style>
</head>
<body>
  <!-- Parallax layers -->
  <div class="plx l1"></div>
  <div class="plx l2"></div>
  <div class="plx l3"></div>

  <!-- SIDEBAR -->
  <aside id="sidebar" class="sidebar glass">
    <div class="flex items-center justify-between gap-2">
      <button id="btnCollapse" class="btn btn-muted" title="Sidebar ein-/ausklappen">☰</button>
    </div>
    <div class="grid gap-2 mt-1">
      <button class="btn btn-muted" data-nav="setup">🏠 <span class="icon-label">Start / Setup</span></button>
      <button class="btn btn-muted" data-nav="game">📋 <span class="icon-label">Scoreboard</span></button>
      <button class="btn btn-muted" data-nav="analytics">📈 <span class="icon-label">Analytics</span></button>
      <button class="btn btn-muted" data-nav="history">🗂️ <span class="icon-label">Spielstände</span></button>
      <button class="btn btn-muted" data-nav="rules">📜 <span class="icon-label">Regeln</span></button>
      <button class="btn btn-muted" data-nav="settings">⚙️ <span class="icon-label">Settings</span></button>
      <button id="btnHome" class="btn btn-primary">🏠 <span class="icon-label">Zur Startseite</span></button>
    </div>
    <div class="text-xs opacity-80 mt-auto">© <span id="year"></span> Pascal Asch</div>
  </aside>
  <div id="mobileShade"></div>

  <!-- CONTENT -->
  <main id="content" class="content">
    <!-- SETUP -->
    <section id="view-setup" class="grid xl:grid-cols-2 gap-3">
      <div class="glass p-4 grid gap-4">
        <h1 class="text-2xl font-black" style="color:var(--accent)">Start / Setup</h1>

        <div class="grid gap-2">
          <label class="font-semibold">Spieler</label>
          <div id="playerInputs" class="space-y-2">
            <input class="input w-full px-4 py-4 rounded-xl" type="text" placeholder="Spieler 1" oninput="UI.addNext(this)">
          </div>
          <div class="text-sm" style="color:var(--muted)">Reihenfolge = Sitzreihenfolge (Dealer = erster Name in Runde 1)</div>
        </div>

        <!-- Modus & Rundenregel -->
        <div class="setup-opts">
          <div class="grid gap-2 minw0">
            <label class="font-semibold">Modus</label>
            <div id="segMode" class="seg">
              <button data-val="classic" class="active">Classic</button>
              <button data-val="plusminus">Plus/Minus&nbsp;Eins</button>
              <button data-val="leaderOnly">Leader-Only</button>
            </div>
          </div>
          <div class="grid gap-2 minw0">
            <label class="font-semibold">Rundenregel</label>
            <div id="segRounds" class="seg">
              <button data-val="official" class="active">Offiziell</button>
              <button data-val="custom">Benutzerdefiniert</button>
            </div>
            <div id="customRoundsWrap" class="hidden grid grid-cols-2 gap-2 text-sm mt-1">
              <label class="flex items-center">3 Spieler: <input id="r3" type="number" min="1" class="input ml-2 w-20 px-2 py-1 rounded" value="20"></label>
              <label class="flex items-center">4 Spieler: <input id="r4" type="number" min="1" class="input ml-2 w-20 px-2 py-1 rounded" value="15"></label>
              <label class="flex items-center">5 Spieler: <input id="r5" type="number" min="1" class="input ml-2 w-20 px-2 py-1 rounded" value="12"></label>
              <label class="flex items-center">6 Spieler: <input id="r6" type="number" min="1" class="input ml-2 w-20 px-2 py-1 rounded" value="10"></label>
            </div>
          </div>
          <div class="col-span-2 mt-1">
            <label class="flex items-center gap-2">
              <input id="hiddenBids" type="checkbox" class="h-5 w-5">
              <span>Verdeckte Ansagen (anzeigen, wenn alle getippt haben)</span>
            </label>
          </div>
        </div>

        <div class="flex flex-wrap items-center justify-center gap-3 pt-1">
          <button id="btnStart" class="btn btn-primary text-lg">🚀 Spiel starten</button>
          <button id="btnLoad" class="btn btn-muted text-lg hidden">📂 Fortsetzen</button>
          <button id="btnOpenSaves" class="btn btn-muted text-lg" data-nav="history">💾 Spielstände</button>
        </div>
        <div id="setupError" class="text-red-500 font-semibold text-center"></div>
      </div>

      <!-- rechte Home-Spalte -->
      <div class="grid gap-3">
        <div class="glass p-4">
          <h2 class="font-extrabold mb-3" style="color:var(--accent)">Regeln</h2>
          <div class="grid sm:grid-cols-2 gap-2 text-sm">
            <div class="glass p-3"><div class="font-bold mb-1">Deck</div><div>60 Karten: 4×(1–13) + 4 Zauberer + 4 Narren</div></div>
            <div class="glass p-3"><div class="font-bold mb-1">Runden</div><div>Runde r → r Karten pro Person · N = 60 ÷ Spieler</div></div>
            <div class="glass p-3"><div class="font-bold mb-1">Trumpf</div><div>Aufgedeckte Karte = Trumpf; Narr = kein Trumpf; Zauberer = Dealer wählt; letzte Runde: kein Trumpf</div></div>
            <div class="glass p-3"><div class="font-bold mb-1">Wertung</div><div>Treffer: <b>20 + 10×Stiche</b> · Daneben: <b>−10 × Differenz</b></div></div>
          </div>
          <div class="mt-3 flex justify-center"><button class="btn btn-muted" data-nav="rules">Mehr Regeln →</button></div>
        </div>

        <div class="glass p-4">
          <h2 class="font-extrabold mb-2" style="color:var(--accent)">Schnellzugriff: Analytics</h2>
          <div class="text-sm" style="color:var(--muted)">Globale Auswertung aller gespeicherten Spiele oder Live-Analytics.</div>
          <div class="mt-3 flex justify-center"><button class="btn btn-muted" data-nav="analytics">Analytics öffnen →</button></div>
        </div>

        <div class="glass p-4">
          <h2 class="font-extrabold mb-2" style="color:var(--accent)">Letzte Spielstände</h2>
          <div id="savesListHome" class="grid gap-2 text-sm"></div>
          <div class="mt-2 flex justify-center"><button class="btn btn-muted" data-nav="history">Alle Spielstände →</button></div>
        </div>
      </div>
    </section>

    <!-- GAME -->
    <section id="view-game" class="hidden">
      <div class="grid-2cols">
        <!-- LEFT -->
        <div class="leftPanel">
          <div class="glass p-4 grid md:grid-cols-3 gap-2">
            <div>
              <div class="text-sm" style="color:var(--muted)">Runde</div>
              <div id="roundProgress" class="text-2xl font-extrabold -mt-1">1/—</div>
            </div>
            <div id="dealerLine" class="text-sm md:text-base">🃏 Kartengeber: –</div>
            <div id="starterLine" class="text-sm md:text-base">🎤 Ansage beginnt bei: –</div>
            <div id="tricksLine" class="md:col-span-3">🎯 Mögliche Stiche: –</div>
          </div>

          <div class="glass p-4 grid gap-2">
            <div id="phaseTitle" class="text-xl font-extrabold" style="color:var(--accent)">Vorhersage</div>
            <div id="phaseHint" class="text-sm" style="color:var(--muted)">Offene Ansagen</div>
            <div id="whoPrompt" class="text-2xl font-bold">Wie viele Stiche …?</div>
            <div id="numberDisplay" class="text-6xl font-black select-none" style="color:var(--accent)">0</div>
            <div id="remainInfo" class="text-sm" style="color:var(--muted)"></div>
            <div id="inputError" class="text-red-500 font-semibold min-h-[1.2em]"></div>
          </div>

          <div id="keypadWrap" class="glass p-3">
            <div class="grid grid-cols-3 gap-2 select-none">
              <button class="py-5 rounded-xl input text-2xl font-black" onclick="Game.d('1')">1</button>
              <button class="py-5 rounded-xl input text-2xl font-black" onclick="Game.d('2')">2</button>
              <button class="py-5 rounded-xl input text-2xl font-black" onclick="Game.d('3')">3</button>
              <button class="py-5 rounded-xl input text-2xl font-black" onclick="Game.d('4')">4</button>
              <button class="py-5 rounded-xl input text-2xl font-black" onclick="Game.d('5')">5</button>
              <button class="py-5 rounded-xl input text-2xl font-black" onclick="Game.d('6')">6</button>
              <button class="py-5 rounded-xl input text-2xl font-black" onclick="Game.d('7')">7</button>
              <button class="py-5 rounded-xl input text-2xl font-black" onclick="Game.d('8')">8</button>
              <button class="py-5 rounded-xl input text-2xl font-black" onclick="Game.d('9')">9</button>
              <button class="py-5 rounded-xl input text-2xl font-black" onclick="Game.cl()">⌫</button>
              <button class="py-5 rounded-xl input text-2xl font-black" onclick="Game.d('0')">0</button>
              <button class="py-5 rounded-xl text-white text-2xl font-black" style="background:linear-gradient(90deg,var(--accent),var(--accent2))" onclick="Game.ok()">OK</button>
            </div>
          </div>
        </div>

        <!-- RIGHT -->
        <div class="rightPanel">
          <div class="glass p-3">
            <div class="flex items-center justify-between mb-2">
              <h2 class="font-bold" style="color:var(--accent)">🪄 Spielverlauf</h2>
              <div class="hidden md:flex gap-2">
                <button id="btnRedoRound" class="btn btn-muted">🔁 Runde neu</button>
                <button id="btnEnd" class="btn btn-primary">🏁 Beenden</button>
                <button id="btnReset" class="btn btn-danger">🔄 Reset</button>
              </div>
            </div>
            <div class="overflow-x-auto">
              <table class="min-w-full text-sm text-center" id="roundTable">
                <thead>
                  <tr class="table-head-1" id="hdr1"></tr>
                  <tr class="table-head-2" id="hdr2"></tr>
                </thead>
                <tbody id="tbody"></tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- ANALYTICS -->
    <section id="view-analytics" class="hidden grid gap-3">
      <div class="glass p-3 flex gap-2 justify-between items-center">
        <div class="font-extrabold" style="color:var(--accent)">Analytics</div>
        <div class="flex gap-2">
          <button id="btnAnaCurrent" class="btn btn-muted">Aktuelles Spiel</button>
          <button id="btnAnaGlobal" class="btn btn-primary">Alle Spielstände</button>
        </div>
      </div>

      <div id="ana-current" class="grid grid-cols-1 lg:grid-cols-2 gap-3">
        <div class="glass p-4" data-chartbox="chartPoints"><h3 class="font-extrabold mb-2" style="color:var(--accent)">Punkteverlauf (Runden)</h3><div class="h-240"><canvas id="chartPoints"></canvas></div></div>
        <div class="glass p-4" data-chartbox="chartCorrect"><h3 class="font-extrabold mb-2" style="color:var(--accent)">Korrekte Tipps</h3><div class="h-240"><canvas id="chartCorrect"></canvas></div></div>
        <div class="glass p-4 lg:col-span-2" data-chartbox="chartExtremes"><h3 class="font-extrabold mb-2" style="color:var(--accent)">Max. Stiche & Größte Abweichung</h3><div class="h-240"><canvas id="chartExtremes"></canvas></div></div>
        <div class="glass p-4 lg:col-span-2" data-chartbox="chartAccuracy"><h3 class="font-extrabold mb-2" style="color:var(--accent)">Trefferquote (%)</h3><div class="h-240"><canvas id="chartAccuracy"></canvas></div></div>
      </div>

      <div id="ana-global" class="grid grid-cols-1 lg:grid-cols-2 gap-3">
        <div class="glass p-4" data-chartbox="gaWins"><h3 class="font-extrabold mb-2" style="color:var(--accent)">Siege (alle Spiele)</h3><div class="h-240"><canvas id="gaWins"></canvas></div></div>
        <div class="glass p-4" data-chartbox="gaAvgScore"><h3 class="font-extrabold mb-2" style="color:var(--accent)">Ø Endpunkte pro Spieler</h3><div class="h-240"><canvas id="gaAvgScore"></canvas></div></div>
        <div class="glass p-4 lg:col-span-2" data-chartbox="gaBestScore"><h3 class="font-extrabold mb-2" style="color:var(--accent)">Beste Punkte (Highscore)</h3><div class="h-240"><canvas id="gaBestScore"></canvas></div></div>
        <div class="glass p-4 lg:col-span-2" data-chartbox="gaAccuracy"><h3 class="font-extrabold mb-2" style="color:var(--accent)">Ø Trefferquote (%)</h3><div class="h-240"><canvas id="gaAccuracy"></canvas></div></div>
        <div class="glass p-4 lg:col-span-2" data-chartbox="gaExtremes"><h3 class="font-extrabold mb-2" style="color:var(--accent)">Extrema: Max. Stiche / Max. Abweichung</h3><div class="h-240"><canvas id="gaExtremes"></canvas></div></div>
      </div>
    </section>

    <!-- HISTORY -->
    <section id="view-history" class="hidden grid md:grid-cols-2 xl:grid-cols-3 gap-3">
      <div class="glass p-4 md:col-span-2 xl:col-span-3 flex items-center justify-between">
        <h3 class="text-xl font-extrabold" style="color:var(--accent)">Spielstände & Hall of Fame</h3>
        <div class="flex gap-2">
          <button class="btn btn-muted" onclick="Saves.exportJSON()">⬇️ Export JSON</button>
          <button class="btn btn-muted" onclick="Saves.importJSON()">⬆️ Import JSON</button>
        </div>
      </div>
      <div id="savesList" class="grid md:grid-cols-2 xl:grid-cols-3 gap-3 md:col-span-2 xl:col-span-3"></div>
    </section>

    <!-- RULES -->
    <section id="view-rules" class="hidden grid gap-3">
      <div class="glass p-5">
        <h3 class="text-xl font-extrabold mb-4" style="color:var(--accent)">Regeln</h3>
        <div class="grid lg:grid-cols-2 gap-3 text-sm">
          <div class="glass p-4"><div class="font-bold mb-1">1) Deck</div><div>60 Karten: 4×(1–13), 4× Zauberer, 4× Narr.</div></div>
          <div class="glass p-4"><div class="font-bold mb-1">2) Runden</div><div>In Runde r erhält jede Person r Karten. Max. Runden N = <b>60 ÷ Spieler</b> (3→20, 4→15, 5→12, 6→10).</div></div>
          <div class="glass p-4"><div class="font-bold mb-1">3) Trumpf</div><div>Aufgedeckte Karte = Trumpf. Narr = kein Trumpf. Zauberer = Dealer wählt Trumpf. Letzte Runde ohne Trumpf.</div></div>
          <div class="glass p-4"><div class="font-bold mb-1">4) Ansage</div><div>Start links vom Dealer. Optional verdeckt. Varianten: <i>Plus/Minus Eins</i> (Summe ≠ r), <i>Leader-Only</i> (Führender darf Summe nicht „even“ machen).</div></div>
          <div class="glass p-4 lg:col-span-2"><div class="font-bold mb-1">5) Wertung</div><div>Treffer: <b>20 + 10×Stiche</b> · Daneben: <b>−10 × Differenz</b> · Korrekt 0 angesagt = 20 Punkte.</div></div>
        </div>
      </div>
    </section>

    <!-- SETTINGS -->
    <section id="view-settings" class="hidden grid gap-3">
      <div class="glass p-4 flex items-center justify-between">
        <div>
          <div class="font-semibold">Dark Mode</div>
          <div class="text-sm" style="color:var(--muted)">Schaltet die edle Nachtansicht um.</div>
        </div>
        <label class="inline-flex items-center cursor-pointer">
          <input id="toggleDark" type="checkbox" class="sr-only peer">
          <div class="w-14 h-8 bg-gray-300 rounded-full peer-checked:bg-indigo-500 relative">
            <div class="absolute top-1 left-1 w-6 h-6 bg-white rounded-full transition-all peer-checked:left-7"></div>
          </div>
        </label>
      </div>
    </section>
  </main>

  <!-- END OVERLAY -->
  <div id="endView" class="hidden fixed inset-0 bg-black/30 p-3 md:p-8">
    <div id="endContainer" class="mx-auto max-w-6xl grid md:grid-cols-2 gap-4 md:gap-6 h-full">
      <section class="glass p-4 md:p-6 panel">
        <h3 class="text-3xl font-extrabold mb-2" style="color:var(--accent)">Endergebnis</h3>
        <div id="finalResult" class="mb-3"></div>
        <div id="extraStats" class="mb-4"></div>
        <div id="endScroll" class="grid grid-cols-1 gap-3">
          <div class="glass p-3"><div class="font-bold mb-1">Punkteverlauf</div><div class="h-180"><canvas id="endC1"></canvas></div></div>
          <div class="glass p-3"><div class="font-bold mb-1">Endpunkte</div><div class="h-180"><canvas id="endC2"></canvas></div></div>
          <div class="glass p-3"><div class="font-bold mb-1">Korrekte Tipps</div><div class="h-180"><canvas id="endC3"></canvas></div></div>
          <div class="glass p-3"><div class="font-bold mb-1">Extrema</div><div class="h-180"><canvas id="endC4"></canvas></div></div>
        </div>
        <div class="mt-3 grid grid-cols-2 gap-3">
          <button class="btn btn-primary" onclick="UI.csv()">⬇️ CSV</button>
          <button class="btn btn-danger" onclick="UI.restart()">Neues Spiel</button>
        </div>
      </section>
      <section class="glass p-4 md:p-6 panel">
        <h3 class="text-2xl font-bold mb-2" style="color:var(--accent)">Abschließender Verlauf</h3>
        <div class="overflow-x-auto grow">
          <table class="min-w-full text-sm text-center" id="finalTable">
            <thead class="table-head-1">
              <tr id="finalHdr"></tr>
            </thead>
            <tbody id="finalBody"></tbody>
          </table>
        </div>
      </section>
    </div>
  </div>

  <!-- SAVE DETAIL OVERLAY -->
  <div id="saveDetail" class="hidden fixed inset-0 bg-black/40 p-3 md:p-6">
    <div class="glass mx-auto max-w-7xl w-full h-[calc(100vh-24px)] md:h-[calc(100vh-48px)] p-4 md:p-6 flex flex-col">
      <div class="flex items-center justify-between mb-2">
        <div>
          <div id="sdTitle" class="text-xl font-extrabold" style="color:var(--accent)">Spiel-Details</div>
          <div id="sdMeta" class="text-sm" style="color:var(--muted)"></div>
        </div>
        <div class="flex gap-2">
          <button id="btnSdClose" class="btn btn-muted">✖️ Schließen</button>
        </div>
      </div>
      <div class="grid grid-cols-1 lg:grid-cols-2 gap-3 flex-1 overflow-hidden">
        <div class="glass p-3"><div class="font-bold mb-1">Punkteverlauf</div><div class="h-240"><canvas id="sdPoints"></canvas></div></div>
        <div class="glass p-3"><div class="font-bold mb-1">Endpunkte</div><div class="h-240"><canvas id="sdScores"></canvas></div></div>
        <div class="glass p-3"><div class="font-bold mb-1">Korrekte Tipps</div><div class="h-240"><canvas id="sdCorrect"></canvas></div></div>
        <div class="glass p-3"><div class="font-bold mb-1">Extrema</div><div class="h-240"><canvas id="sdExtremes"></canvas></div></div>
      </div>
    </div>
  </div>

  <!-- Center Toast -->
  <div id="toast"><div class="glass bubble"></div></div>

  <script>
    const $ = s => document.querySelector(s), $$ = s => Array.from(document.querySelectorAll(s));
    const saveKey = 'wizard.touch.v9';
    const savesKey = 'wizard.touch.v9.saves'; // (Legacy) – wird migriert
    const settingsKey='wizard.touch.v9.settings';
    const fmt = n => (n>=0? '+'+n : n);

    // NEU: globaler Container + Schema
    const GAME_ID = 'wizard';
    const SAVE_SCHEMA = 1;
    const GLOBAL_SAVES_KEY = 'pascal.spiele.saves.v1';

    const S = {
      players:[], round:1, maxRounds:0, step:'prediction', stepIndex:0,
      mode:'classic', hiddenBids:false, roundRule:'official',
      customRounds:{3:20,4:15,5:12,6:10},
      predictions:[], results:[], scores:{}, history:[], savedFinal:false
    };
    const Settings = { theme:'light', sidebar:'expanded' };

    /* ---------- Storage (robust) ---------- */
    const safeLS = {
      get(k){ try { return localStorage.getItem(k); } catch { return null; } },
      set(k,v){ try { localStorage.setItem(k,v); } catch {} },
      remove(k){ try { localStorage.removeItem(k); } catch {} }
    };

    const Storage = {
      save(){ safeLS.set(saveKey, JSON.stringify(S)); },
      load(){
        const d = safeLS.get(saveKey);
        if(!d) return false;
        try { Object.assign(S, JSON.parse(d)); return true; }
        catch { return false; }
      },
      clear(){ safeLS.remove(saveKey); },
      saveSettings(){ safeLS.set(settingsKey, JSON.stringify(Settings)); },
      loadSettings(){
        const d = safeLS.get(settingsKey);
        if(d){ try { Object.assign(Settings, JSON.parse(d)); } catch {} }
      }
    };

    /* ---------- Save-Erkennung/Normalisierung (NEU) ---------- */
    function looksLikeWizardSave(e){
      return !!e && (
        e.gameId === GAME_ID ||
        (Array.isArray(e.players) &&
         Array.isArray(e.predictions) &&
         Array.isArray(e.results) &&
         e.scores && typeof e.scores === 'object' &&
         !('hands' in e) && !('points' in e)) // grenzt Rummikub aus
      );
    }
    function normalizeSave(e){
      if(!e) return null;
      if(e.gameId && e.gameId !== GAME_ID) return null;
      if(!looksLikeWizardSave(e)) return null;
      return { ...e, gameId: GAME_ID, schema: (e.schema ?? SAVE_SCHEMA) };
    }

    /* ---------- Saves (global, nur Wizard gefiltert) ---------- */
    const Saves = {
      all(){
        const rawGlobal = safeLS.get(GLOBAL_SAVES_KEY);
        const globalArr = rawGlobal ? JSON.parse(rawGlobal) : [];

        // Aus dem globalen Container nur Wizard-Einträge ziehen/normalisieren
        let wiz = globalArr.map(normalizeSave).filter(Boolean);

        // MIGRATION: alte lokale Liste -> in globalen Container überführen
        const legacyRaw = safeLS.get(savesKey);
        if (legacyRaw) {
          let legacy = [];
          try { legacy = JSON.parse(legacyRaw); } catch {}
          const legacyNorm = (Array.isArray(legacy) ? legacy : [])
            .map(x => normalizeSave({ ...x, gameId: GAME_ID, schema: SAVE_SCHEMA }))
            .filter(Boolean);

          if (legacyNorm.length) {
            // alles Nicht-Wizard im globalen Container bewahren (auch ohne gameId)
            const others = globalArr.filter(x => !looksLikeWizardSave(x));
            // zusammenführen + deduplizieren nach id/ts
            const seen = new Set();
            const mergedWiz = [...legacyNorm, ...wiz].filter(x => {
              const k = x.id || (x.ts ? 'ts_'+x.ts : JSON.stringify(x.players||[]));
              if (seen.has(k)) return false;
              seen.add(k); return true;
            });
            safeLS.set(GLOBAL_SAVES_KEY, JSON.stringify([...mergedWiz, ...others]));
            safeLS.remove(savesKey); // Legacy-Key leeren
            wiz = mergedWiz;
          }
        }
        return wiz;
      },

      writeWizardList(list){
        const raw = safeLS.get(GLOBAL_SAVES_KEY);
        const all = raw ? JSON.parse(raw) : [];
        // bewahre alles, was NICHT nach Wizard aussieht
        const others = all.filter(x => !looksLikeWizardSave(x));
        safeLS.set(GLOBAL_SAVES_KEY, JSON.stringify([...list, ...others]));
      },

      add(e){
        const entry = normalizeSave({ ...e, gameId: GAME_ID, schema: SAVE_SCHEMA });
        const a = this.all();
        a.unshift(entry);
        this.writeWizardList(a);
        UI.renderSaves(); UI.renderSavesHome(); UI.updateGlobalCharts();
      },

      remove(id){
        const a = this.all().filter(x => x.id !== id);
        this.writeWizardList(a);
        UI.renderSaves(); UI.renderSavesHome(); UI.updateGlobalCharts();
      },

      exportJSON(){
        const blob = new Blob([JSON.stringify(this.all(),null,2)],{type:'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'wizard_saves.json'; a.click();
        URL.revokeObjectURL(url);
      },

      importJSON(){
        const inp=document.createElement('input'); inp.type='file'; inp.accept='application/json';
        inp.onchange=()=>{ const f=inp.files[0]; if(!f) return; const r=new FileReader();
          r.onload=()=>{ try{
              const incoming = JSON.parse(r.result);
              const valid = (Array.isArray(incoming)? incoming:[]).map(normalizeSave).filter(Boolean);
              const merged = [...valid, ...this.all()];
              const seen = new Set();
              const deduped = merged.filter(x=>{
                const k = x.id || (x.ts ? 'ts_'+x.ts : JSON.stringify(x.players||[]));
                if(seen.has(k)) return false; seen.add(k); return true;
              });
              this.writeWizardList(deduped);
              UI.renderSaves(); UI.renderSavesHome(); UI.updateGlobalCharts();
              alert(`Import: ${valid.length} gültige Wizard-Spielstände übernommen.`);
            } catch { alert('Ungültige Datei.'); } };
          r.readAsText(f);
        };
        inp.click();
      },

      saveFinished(silent=false){
        const entry={ id:'g_'+Date.now(), ts:new Date().toISOString(),
          gameId: GAME_ID, schema: SAVE_SCHEMA,
          players:[...S.players],
          mode:S.mode, hiddenBids:S.hiddenBids,
          rounds:S.maxRounds, scores:{...S.scores},
          predictions:S.predictions, results:S.results,
          summary:Analytics.computeSummary()
        };
        const a=this.all(); a.unshift(entry); this.writeWizardList(a);
        UI.renderSaves(); UI.renderSavesHome(); UI.updateGlobalCharts();
        if(!silent) alert('Spielstand gespeichert.');
      }
    };

    /* ---------- Rules & scoring ---------- */
    const roundsForPlayers = n => Math.floor(60/n);
    const pointsFor = (pred,got)=> pred===got? (20+10*got) : (-10*Math.abs(pred-got));
    function computeMaxRounds(){ return (S.roundRule==='official')? roundsForPlayers(S.players.length) : (S.customRounds[S.players.length]||roundsForPlayers(S.players.length)); }
    function recalcScores(){
      S.players.forEach(p=>S.scores[p]=0);
      for(let i=0;i<S.predictions.length;i++){
        const P=S.predictions[i]||{}, R=S.results[i]||{};
        if(Object.keys(P).length<S.players.length) continue;
        if(Object.keys(R).length<S.players.length) continue;
        S.players.forEach(pl=>{ S.scores[pl]+=pointsFor(P[pl]??0,R[pl]??0); });
      }
    }

    /* ---------- Analytics helpers ---------- */
    const Analytics = {
      perRoundTotalsGeneric(players,predictions,results){
        const totals=players.map(()=>[]), acc=players.map(()=>0);
        for(let i=0;i<predictions.length;i++){
          const P=predictions[i]||{}, R=results[i]||{};
          const full=(Object.keys(P).length===players.length && Object.keys(R).length===players.length);
          players.forEach((pl,pi)=>{ if(full){ acc[pi]+=pointsFor(P[pl]??0,R[pl]??0);} totals[pi].push(acc[pi]); });
        }
        return totals;
      },
      perRoundTotals(){ return this.perRoundTotalsGeneric(S.players,S.predictions,S.results); },
      correctCountsGeneric(players,predictions,results){
        const m=Object.fromEntries(players.map(p=>[p,0]));
        for(let i=0;i<predictions.length;i++){
          const P=predictions[i]||{}, R=results[i]||{};
          if(Object.keys(P).length<players.length || Object.keys(R).length<players.length) continue;
          players.forEach(pl=>{ if((P[pl]??-1)===(R[pl]??-2)) m[pl]++; });
        } return m;
      },
      correctCounts(){ return this.correctCountsGeneric(S.players,S.predictions,S.results); },
      extremesGeneric(players,predictions,results){
        const maxTricks=Object.fromEntries(players.map(p=>[p,0])), maxDev=Object.fromEntries(players.map(p=>[p,0]));
        for(let i=0;i<results.length;i++){ const P=predictions[i]||{}, R=results[i]||{};
          players.forEach(pl=>{ const r=R[pl]; const g=P[pl];
            if(r!=null && r>maxTricks[pl]) maxTricks[pl]=r;
            if(r!=null && g!=null){ const d=Math.abs(r-g); if(d>maxDev[pl]) maxDev[pl]=d; }
          });
        } return {maxTricks,maxDev};
      },
      extremes(){ return this.extremesGeneric(S.players,S.predictions,S.results); },
      accuracy(){
        const corr=this.correctCounts(); const totals=Object.fromEntries(S.players.map(p=>[p,0]));
        for(let i=0;i<S.predictions.length;i++){
          const P=S.predictions[i]||{}, R=S.results[i]||{};
          if(Object.keys(P).length<S.players.length || Object.keys(R).length<S.players.length) continue;
          S.players.forEach(p=>totals[p]++);
        }
        const pct=Object.fromEntries(S.players.map(p=>[p, totals[p]? Math.round((corr[p]/totals[p])*100):0 ]));
        return pct;
      },
      computeSummary(){
        const corr=this.correctCounts(); const acc=this.accuracy(); const ex=this.extremes();
        let bestScore=-Infinity,bestPlayers=[];
        S.players.forEach(p=>{ if(S.scores[p]>bestScore){bestScore=S.scores[p];bestPlayers=[p]} else if(S.scores[p]===bestScore){bestPlayers.push(p)} });
        return {bestPlayers,bestScore,correct:corr,accuracy:acc,extremes:ex};
      }
    };

    function ensureSummaryFromEntry(e){
      if(e.summary) return e.summary;
      const players = e.players||[];
      const predictions = e.predictions||[];
      const results = e.results||[];
      // correct counts
      const correct = Analytics.correctCountsGeneric(players,predictions,results);
      // accuracy
      const totals=Object.fromEntries(players.map(p=>[p,0]));
      for(let i=0;i<predictions.length;i++){
        const P=predictions[i]||{}, R=results[i]||{};
        if(Object.keys(P).length===players.length && Object.keys(R).length===players.length) players.forEach(p=>totals[p]++);
      }
      const accuracy=Object.fromEntries(players.map(p=>[p, totals[p]? Math.round((correct[p]/totals[p])*100):0]));
      const ex=Analytics.extremesGeneric(players,predictions,results);
      let best=-Infinity,bp=[]; players.forEach(p=>{ const s=(e.scores||{})[p]||0; if(s>best){best=s;bp=[p]} else if(s===best){bp.push(p)} });
      return {bestPlayers:bp, bestScore:best, correct, accuracy, extremes:ex};
    }

    function globalAggregates(){
      const arr = Saves.all(); // nur Wizard
      const wins = {}, games = {}, sumScore = {}, bestScore = {}, sumAccuracy = {}, accCount = {}, maxTricks = {}, maxDev = {};
      const inc = (m,k,v=1)=>{ m[k]=(m[k]||0)+v; };
      const setMax = (m,k,v)=>{ m[k]=Math.max(m[k]||0, v||0); };

      arr.forEach(e=>{
        const players=e.players||[], scores=e.scores||{}, sum=ensureSummaryFromEntry(e);
        (sum.bestPlayers||[]).forEach(p=> inc(wins,p,1));
        players.forEach(p=>{
          inc(games,p,1);
          inc(sumScore,p, scores[p]||0);
          setMax(bestScore,p, scores[p]||0);
          const acc = (sum.accuracy && typeof sum.accuracy[p]==='number') ? sum.accuracy[p] : 0;
          inc(sumAccuracy,p, acc); inc(accCount,p, acc?1:0);
          if(sum.extremes){
            setMax(maxTricks,p, (sum.extremes.maxTricks||{})[p]||0);
            setMax(maxDev,p, (sum.extremes.maxDev||{})[p]||0);
          }
        });
      });

      const players = Object.keys(games).sort((a,b)=>(wins[b]||0)-(wins[a]||0));
      const avgScore = players.map(p=> games[p]? Math.round((sumScore[p]/games[p])*10)/10 : 0);
      const best = players.map(p=> bestScore[p]||0);
      const winVals = players.map(p=> wins[p]||0);
      const avgAcc = players.map(p=> (accCount[p]? Math.round(sumAccuracy[p]/accCount[p]) : 0));
      const maxT = players.map(p=> maxTricks[p]||0);
      const maxD = players.map(p=> maxDev[p]||0);

      return {players, winVals, avgScore, best, avgAcc, maxT, maxD, totalGames: arr.length};
    }

    /* ---------- UI ---------- */
    let chartPoints, chartCorrect, chartExtremes, chartAccuracy;
    let gaWins, gaAvg, gaBest, gaAcc, gaExt;
    let sdC1, sdC2, sdC3, sdC4;
    let endCharts=[];

    function showView(v){
      ['setup','game','analytics','history','rules','settings'].forEach(x=>$('#view-'+x)?.classList.toggle('hidden', v!==x));
      if(v==='analytics'){ UI.updateCharts(); UI.updateGlobalCharts(); }
      if(v==='history'){ UI.renderSaves(); }
      if(v==='setup'){ UI.renderSavesHome(); }
    }

    const UI = {
      init(){
        $('#year').textContent=new Date().getFullYear();

        // Global nav
        $$('[data-nav]').forEach(btn=> btn.addEventListener('click', ()=>{
          showView(btn.dataset.nav);
          if(window.innerWidth<=900){ $('#sidebar').classList.remove('open'); }
          if(btn.dataset.nav==='analytics'){ $('#btnAnaGlobal').click(); }
        }));

        // Sidebar collapse
        $('#btnCollapse').onclick = ()=>{
          const sb = $('#sidebar'), ct = $('#content');
          if(window.innerWidth<=900){ sb.classList.toggle('open'); return; }
          sb.classList.toggle('collapsed'); ct.classList.toggle('shifted');
          Settings.sidebar = sb.classList.contains('collapsed') ? 'collapsed' : 'expanded';
          Storage.saveSettings();
        };

        // Settings load
        Storage.loadSettings();
        document.documentElement.setAttribute('data-theme', Settings.theme||'light');
        if(Settings.sidebar==='collapsed'){ $('#sidebar').classList.add('collapsed'); $('#content').classList.add('shifted'); }
        const t = $('#toggleDark'); if(t) t.checked = (Settings.theme==='dark');
        $('#toggleDark')?.addEventListener('change',(e)=>{ Settings.theme=e.target.checked?'dark':'light'; document.documentElement.setAttribute('data-theme', Settings.theme); Storage.saveSettings(); });

        // Actions
        $('#btnStart').onclick=Handlers.start;
        $('#btnLoad').onclick=Handlers.load;
        $('#btnReset').onclick=Handlers.reset;
        $('#btnEnd').onclick=Handlers.end;
        $('#btnRedoRound').onclick=Handlers.redoRound;
        $('#btnOpenSaves').onclick=()=>{ showView('history'); };
        $('#btnHome').onclick=()=>{ location.href='https://pascalasch.github.io/Spiele/Overview.html'; };
        $('#btnSdClose').onclick = ()=> UI.closeSaveDetail();
        $('#saveDetail').addEventListener('click', (e)=>{ if(e.target.id==='saveDetail') UI.closeSaveDetail(); });

        // Segmented controls
        $('#segMode').addEventListener('click', e=>{
          if(e.target.tagName!=='BUTTON') return;
          $$('#segMode button').forEach(b=>b.classList.remove('active'));
          e.target.classList.add('active'); S.mode = e.target.dataset.val; Storage.save();
        });
        $('#segRounds').addEventListener('click', e=>{
          if(e.target.tagName!=='BUTTON') return;
          $$('#segRounds button').forEach(b=>b.classList.remove('active'));
          e.target.classList.add('active'); S.roundRule = e.target.dataset.val;
          $('#customRoundsWrap').classList.toggle('hidden', S.roundRule!=='custom'); Storage.save();
        });

        if(safeLS.get(saveKey)) $('#btnLoad').classList.remove('hidden');

        document.addEventListener('touchstart',()=>{}, {passive:true});

        UI.renderSavesHome();
        $('#btnAnaGlobal').click();

        // Parallax movement
        const layers=$$('.plx');
        function moveParallax(x,y){
          const dx=(x/window.innerWidth-0.5), dy=(y/window.innerHeight-0.5);
          layers.forEach((el,i)=>{ const f=(i+1)*8; el.style.transform=`translate(${dx*f}px, ${dy*f}px) scale(1.05)`; });
        }
        window.addEventListener('mousemove',e=>moveParallax(e.clientX,e.clientY),{passive:true});
        window.addEventListener('touchmove',e=>{ const t=e.touches[0]; if(t) moveParallax(t.clientX,t.clientY); },{passive:true});
      },

      addNext(el){
        const c=$('#playerInputs');
        if(!el.nextElementSibling && el.value.trim()!==''){
          const n=document.createElement('input');
          n.className='input w-full px-4 py-4 rounded-xl';
          n.type='text'; n.placeholder=`Spieler ${c.children.length+1}`;
          n.oninput=()=>UI.addNext(n);
          c.appendChild(n);
        }
      },

      toast(msg){
        const t=$('#toast'); const b=t.querySelector('.bubble');
        b.textContent=msg; t.style.display='block'; b.style.background='var(--glass-bg)'; b.style.color='var(--text)';
        setTimeout(()=>{ t.style.display='none'; }, 2600);
      },

      top(){
        $('#roundProgress').textContent=`${S.round}/${S.maxRounds}`;
        const dealer=S.players[(S.round-1)%S.players.length]||'–';
        const starter=S.players[S.round%S.players.length]||'–';
        $('#dealerLine').innerHTML=`🃏 Kartengeber: <b>${dealer}</b>`;
        $('#starterLine').innerHTML=`🎤 Ansage beginnt bei: <b>${starter}</b>`;
        $('#tricksLine').innerHTML=`🎯 Mögliche Stiche: <b>${S.round}</b>`;
        $('#phaseTitle').textContent=(S.step==='prediction')?'Vorhersage':'Ergebnis';
        $('#phaseHint').textContent=(S.step==='prediction')?(S.hiddenBids?'Verdeckte Ansagen (zeigen nach letzter Ansage)':'Offene Ansagen'):'Erzielte Stiche eingeben';
        const current=S.players[(S.round+S.stepIndex)%S.players.length]||'–';
        $('#whoPrompt').innerHTML=`${(S.step==='prediction')?'Wie viele Stiche sagt':'Wie viele Stiche hat'} <b>${current}</b>?`;
        if(S.step==='result'){
          const R=S.results[S.round-1]||{};
          const partial=Object.values(R).reduce((a,b)=>a+(b||0),0);
          const remain=Math.max(S.round - partial, 0);
          $('#remainInfo').textContent = `Verbleibende Stiche: ${remain}`;
        } else { $('#remainInfo').textContent=''; }
        $('#inputError').textContent='';
      },

      tables(){
        const hdr1=$('#hdr1'), hdr2=$('#hdr2'), body=$('#tbody');
        hdr1.innerHTML=`<th>Runde</th>${S.players.map(p=>`<th>${p}</th>`).join('')}<th></th>`;
        hdr2.innerHTML=`<th>Gesamt</th>${S.players.map(p=>`<th>${S.scores[p]||0}</th>`).join('')}<th></th>`;
        body.innerHTML='';
        for(let i=S.predictions.length-1;i>=0;i--){
          const P=S.predictions[i]||{}, R=S.results[i]||{};
          const allR=Object.keys(R).length===S.players.length;

          if(Object.keys(P).length>0){
            const tr=document.createElement('tr'); tr.className='row-tip';
            tr.innerHTML=`<td class='font-bold'>Runde ${i+1} (Tipp)</td>`+
              S.players.map(pl=>{
                const v=P[pl];
                const hide=S.hiddenBids && i===S.round-1 && S.step==='prediction' && Object.keys(P).length<S.players.length;
                return `<td>${(v!=null && !hide)? `<b>${v}</b>` : (v!=null? '•':'-')}</td>`;
              }).join('') +
              `<td>${(!allR)? `<button class='underline text-red-500' onclick='Handlers.delPred(${i})'>Tipps löschen</button>`:''}</td>`;
            body.appendChild(tr);
          }
          if(allR){
            const pts={}; S.players.forEach(pl=>pts[pl]=pointsFor(P[pl]??0,R[pl]??0));
            const tr=document.createElement('tr'); tr.className='row-res';
            tr.innerHTML=`<td class='font-bold'>Runde ${i+1} (Ergebnis)</td>`+
              S.players.map(pl=>`<td>${R[pl]}<br><span class='text-xs' style='color:var(--accent)'>${fmt(pts[pl])} Pkt</span></td>`).join('')+
              `<td><button class='underline text-red-500' onclick='Handlers.delRes(${i})'>Ergebnisse löschen</button></td>`;
            body.appendChild(tr);
          }
        }
      },

      final(){
        const scores=S.scores;
        let max=-Infinity,w=[];
        S.players.forEach(p=>{ if(scores[p]>max){max=scores[p];w=[p]} else if(scores[p]===max){w.push(p)} });
        $('#finalResult').innerHTML=(w.length===1)? `🏅 <b>${w[0]}</b> gewinnt mit <b>${max}</b> Punkten.` : `🏅 <b>${w.join(' & ')}</b> teilen sich den Sieg (je <b>${max}</b> Punkte).`;

        let full=0,totalErr=0,errCount=0,corr=Object.fromEntries(S.players.map(p=>[p,0]));
        for(let i=0;i<S.predictions.length;i++){
          const P=S.predictions[i]||{}, R=S.results[i]||{};
          if(Object.keys(P).length===S.players.length && Object.keys(R).length===S.players.length){
            full++; S.players.forEach(p=>{ const g=P[p]??0,r=R[p]??0; totalErr+=Math.abs(g-r); errCount++; if(g===r) corr[p]++; });
          }
        }
        const avgErr=errCount? (totalErr/errCount).toFixed(2):'0';
        const maxC=Math.max(...Object.values(corr)), minC=Math.min(...Object.values(corr));
        const best=S.players.filter(p=>corr[p]===maxC).join(', ')||'-';
        const worst=S.players.filter(p=>corr[p]===minC).join(', ')||'-';
        const totalPts=Object.values(S.scores).reduce((a,b)=>a+b,0);
        const avgRoundPts=full? (totalPts/full).toFixed(1):'0';
        const lis=[
          `1. Gespielte Runden: ${full}/${S.maxRounds}`,
          `2. Durchschnittlicher Vorhersagefehler: ${avgErr}`,
          `3. Korrekte Tipps: ${S.players.map(p=>`${p}: ${corr[p]}`).join(' | ')}`,
          `4. Beste Tipp-Genauigkeit: ${best} (${maxC})`,
          `5. Schwächste Tipp-Genauigkeit: ${worst} (${minC})`,
          `6. Ø Gesamtpunktgewinn/Runde: ${avgRoundPts}`
        ];
        $('#extraStats').innerHTML=`<ul class='list-disc ml-5'>${lis.map(s=>`<li>${s}</li>`).join('')}</ul>`;

        const h=$('#finalHdr'), b=$('#finalBody'); h.innerHTML=`<th>Runde</th>${S.players.map(p=>`<th>${p}</th>`).join('')}`; b.innerHTML='';
        for(let i=0;i<S.predictions.length;i++){
          const P=S.predictions[i]||{}, R=S.results[i]||{};
          if(Object.keys(P).length){ const tr=document.createElement('tr'); tr.className='row-tip'; tr.innerHTML=`<td class='font-bold'>Runde ${i+1} (Tipp)</td>`+S.players.map(p=>`<td><b>${P[p]??'-'}</b></td>`).join(''); b.appendChild(tr); }
          if(Object.keys(R).length===S.players.length){ const pts={}; S.players.forEach(pl=>pts[pl]=pointsFor(P[pl]??0,R[pl]??0)); const tr=document.createElement('tr'); tr.className='row-res'; tr.innerHTML=`<td class='font-bold'>Runde ${i+1} (Ergebnis)</td>`+S.players.map(pl=>`<td>${R[pl]}<br><span class='text-xs' style='color:var(--accent)'>${fmt(pts[pl])} Pkt</span></td>`).join(''); b.appendChild(tr); }
        }
      },

      updateEndCharts(){
        endCharts.forEach(c=>c&&c.destroy()); endCharts=[];
        const labels=S.predictions.map((_,i)=>`R${i+1}`);
        const totals=Analytics.perRoundTotals();
        const ds=totals.map((arr,i)=>({ label:S.players[i], data:arr, tension:.25 }));

        const extremes=Analytics.extremes();

        endCharts.push(new Chart($('#endC1'),{ type:'line', data:{labels, datasets:ds}, options:{responsive:true, maintainAspectRatio:false, plugins:{legend:{position:'bottom'}}, scales:{x:{grid:{display:false}}, y:{grid:{color:'rgba(0,0,0,.08)'}}} }}));
        endCharts.push(new Chart($('#endC2'),{ type:'bar', data:{labels:S.players, datasets:[{label:'Punkte', data:S.players.map(p=>S.scores[p])}]}, options:{responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}}}));
        endCharts.push(new Chart($('#endC3'),{ type:'bar', data:{labels:S.players, datasets:[{label:'Korrekte Tipps', data:S.players.map(p=>Analytics.correctCounts()[p])}]}, options:{responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}}}));
        endCharts.push(new Chart($('#endC4'),{ type:'bar', data:{labels:S.players, datasets:[{label:'Max. Stiche', data:S.players.map(p=>extremes.maxTricks[p])},{label:'Größte Abweichung', data:S.players.map(p=>extremes.maxDev[p])}]}, options:{responsive:true, maintainAspectRatio:false}}));
      },

      csv(){
        const rows=[['Round',...S.players.map(p=>`${p} (Tip)`),...S.players.map(p=>`${p} (Res)`)].join(',')];
        for(let i=0;i<S.predictions.length;i++){
          const P=S.predictions[i]||{}, R=S.results[i]||{};
          rows.push([i+1, ...S.players.map(p=>P[p]??''), ...S.players.map(p=>R[p]??'')].join(','));
        }
        const blob=new Blob([rows.join('\n')],{type:'text/csv'}); const url=URL.createObjectURL(blob);
        const a=document.createElement('a'); a.href=url; a.download='wizard_scores.csv'; a.click(); URL.revokeObjectURL(url);
      },

      renderSaves(){
        const box=$('#savesList'); const arr=Saves.all();
        if(!arr.length){ box.innerHTML='<div class="glass p-4 opacity-70">Keine gespeicherten Spiele.</div>'; return; }
        box.innerHTML=arr.map(e=>{
          const date=new Date(e.ts).toLocaleString();
          const rank=Object.entries(e.scores||{}).sort((a,b)=>b[1]-a[1]);
          const winner=rank.length? rank.filter(x=>x[1]===rank[0][1]).map(x=>x[0]).join(' & ') : '–';
          return `<div class='glass p-4 flex flex-col gap-2'>
            <div class='text-sm' style='color:var(--muted)'>${date} · ${e.players.length} Spieler · ${e.rounds} Runden · Modus: ${e.mode}${e.hiddenBids?' · Hidden':''}</div>
            <div><b>Winner:</b> ${winner}${rank.length? ` (${rank[0][1]} Pkt)` : ''}</div>
            <div class='text-sm'>${e.players.map(p=>`${p}: ${e.scores?.[p]??0}`).join(' · ')}</div>
            <div class='flex gap-2 mt-1'>
              <button class='btn btn-muted' onclick='UI.openSaveDetail("${e.id}")'>🔎 Details</button>
              <button class='btn btn-danger' onclick='Saves.remove("${e.id}")'>🗑️ Löschen</button>
            </div>
          </div>`;
        }).join('');
      },

      renderSavesHome(){
        const box=$('#savesListHome'); if(!box) return;
        const arr=Saves.all().slice(0,4);
        if(!arr.length){ box.innerHTML='<div class="opacity-70">Noch keine Spielstände.</div>'; return; }
        box.innerHTML=arr.map(e=>{
          const date=new Date(e.ts).toLocaleDateString();
          const rank=Object.entries(e.scores||{}).sort((a,b)=>b[1]-a[1]);
          return `<div class='glass p-3'>${date}: <b>${rank[0]?.[0]||'–'}</b>${rank[0]? ` (${rank[0][1]} Pkt)` : ''} – ${e.players.length} Spieler</div>`;
        }).join('');
      },

      openSaveDetail(id){
        const e=Saves.all().find(x=>x.id===id); if(!e) return;
        $('#sdTitle').textContent = 'Spiel-Details';
        $('#sdMeta').textContent = new Date(e.ts).toLocaleString() + ` · ${e.players.length} Spieler · ${e.rounds} Runden · Modus: ${e.mode}${e.hiddenBids?' · Hidden':''}`;

        [sdC1,sdC2,sdC3,sdC4].forEach(c=>c&&c.destroy());

        const labels=(e.predictions||[]).map((_,i)=>`R${i+1}`);
        const totals=Analytics.perRoundTotalsGeneric(e.players,e.predictions||[],e.results||[]);
        const ds=totals.map((arr,i)=>({ label:e.players[i], data:arr, tension:.25 }));

        const sum=ensureSummaryFromEntry(e);

        sdC1=new Chart($('#sdPoints'),{ type:'line', data:{labels, datasets:ds},
          options:{responsive:true, maintainAspectRatio:false, plugins:{legend:{position:'bottom'}}, scales:{x:{grid:{display:false}}, y:{grid:{color:'rgba(0,0,0,.08)'}}} }});

        const scorePairs=Object.entries(e.scores||{}).sort((a,b)=>b[1]-a[1]);
        sdC2=new Chart($('#sdScores'),{ type:'bar', data:{labels:scorePairs.map(x=>x[0]), datasets:[{label:'Punkte', data:scorePairs.map(x=>x[1])}]}, options:{responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}} });

        const corr = sum.correct||{};
        sdC3=new Chart($('#sdCorrect'),{ type:'bar', data:{labels:e.players, datasets:[{label:'Korrekte Tipps', data:e.players.map(p=>corr[p]||0)}]}, options:{responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}} });

        const ex = sum.extremes||{maxTricks:{},maxDev:{}};
        sdC4=new Chart($('#sdExtremes'),{ type:'bar', data:{labels:e.players, datasets:[{label:'Max. Stiche', data:e.players.map(p=>ex.maxTricks?.[p]||0)},{label:'Größte Abweichung', data:e.players.map(p=>ex.maxDev?.[p]||0)}]}, options:{responsive:true, maintainAspectRatio:false} });

        $('#saveDetail').classList.remove('hidden');
      },
      closeSaveDetail(){ [sdC1,sdC2,sdC3,sdC4].forEach(c=>c&&c.destroy()); $('#saveDetail').classList.add('hidden'); },

      _emptyBox(id, text){
        const box = document.querySelector(`[data-chartbox="${id}"]`);
        if(!box) return;
        box.querySelector('.h-240').innerHTML = `<div class="h-240 flex items-center justify-center opacity-70 text-center px-4">${text}</div>`;
      },
      _ensureCanvas(id){
        const box = document.querySelector(`[data-chartbox="${id}"]`);
        if(!box) return null;
        const wrap = box.querySelector('.h-240');
        wrap.innerHTML = `<canvas id="${id}"></canvas>`;
        return document.getElementById(id);
      },

      updateCharts(){
        const havePlayers = S.players.length>=2;
        const haveAnyRound = S.predictions.some(p=>Object.keys(p||{}).length>0) || S.results.some(r=>Object.keys(r||{}).length>0);

        [chartPoints,chartCorrect,chartExtremes,chartAccuracy].forEach(c=>c&&c.destroy());

        if(!(havePlayers && haveAnyRound)){
          this._emptyBox('chartPoints','Noch keine Runden – starte ein Spiel.');
          this._emptyBox('chartCorrect','Noch keine vollständigen Runden.');
          this._emptyBox('chartExtremes','Noch keine Ergebnisse.');
          this._emptyBox('chartAccuracy','Noch keine Trefferquoten.');
          return;
        }

        const c1=this._ensureCanvas('chartPoints'), c2=this._ensureCanvas('chartCorrect'),
              c3=this._ensureCanvas('chartExtremes'), c4=this._ensureCanvas('chartAccuracy');

        const labels=S.predictions.map((_,i)=>`R${i+1}`);
        const totals=Analytics.perRoundTotals();
        const ds=totals.map((arr,i)=>({ label:S.players[i], data:arr, tension:.25 }));

        const correct=Analytics.correctCounts();
        const extremes=Analytics.extremes();
        const accuracy=Analytics.accuracy();

        chartPoints=new Chart(c1,{ type:'line', data:{labels, datasets:ds}, options:{responsive:true, maintainAspectRatio:false, plugins:{legend:{position:'bottom'}}, scales:{x:{grid:{display:false}}, y:{grid:{color:'rgba(0,0,0,.08)'}}} }});
        chartCorrect=new Chart(c2,{ type:'bar', data:{labels:S.players, datasets:[{label:'Korrekte Tipps', data:S.players.map(p=>correct[p])}]}, options:{responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}}});
        chartExtremes=new Chart(c3,{ type:'bar', data:{ labels:S.players, datasets:[{label:'Max. Stiche', data:S.players.map(p=>extremes.maxTricks[p])},{label:'Größte Abweichung', data:S.players.map(p=>extremes.maxDev[p])}]}, options:{responsive:true, maintainAspectRatio:false}});
        chartAccuracy=new Chart(c4,{ type:'radar', data:{ labels:S.players, datasets:[{label:'Trefferquote %', data:S.players.map(p=>accuracy[p])}]}, options:{responsive:true, maintainAspectRatio:false, scales:{ r:{ beginAtZero:true, max:100 }}}});
      },

      updateGlobalCharts(){
        [gaWins,gaAvg,gaBest,gaAcc,gaExt].forEach(c=>c&&c.destroy());
        const agg = globalAggregates();

        if(!agg.players.length){
          this._emptyBox('gaWins','Noch keine gespeicherten Spiele.');
          this._emptyBox('gaAvgScore','—');
          this._emptyBox('gaBestScore','—');
          this._emptyBox('gaAccuracy','—');
          this._emptyBox('gaExtremes','—');
          return;
        }

        const players = agg.players.slice(0,16);
        const idx = players.map(p=> agg.players.indexOf(p));
        const pick = (arr)=> idx.map(i=> arr[i]);

        const c1=this._ensureCanvas('gaWins'), c2=this._ensureCanvas('gaAvgScore'),
              c3=this._ensureCanvas('gaBestScore'), c4=this._ensureCanvas('gaAccuracy'),
              c5=this._ensureCanvas('gaExtremes');

        gaWins = new Chart(c1, { type:'bar',
          data:{ labels:players, datasets:[{label:'Siege', data: pick(agg.winVals)}] },
          options:{ responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}, title:{display:true, text:`Gespeicherte Spiele: ${agg.totalGames}`}} }
        });
        gaAvg = new Chart(c2, { type:'bar',
          data:{ labels:players, datasets:[{label:'Ø Endpunkte', data: pick(agg.avgScore)}] },
          options:{ responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}} }
        });
        gaBest = new Chart(c3, { type:'bar',
          data:{ labels:players, datasets:[{label:'Bestscore', data: pick(agg.best)}] },
          options:{ responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}} }
        });
        gaAcc = new Chart(c4, { type:'bar',
          data:{ labels:players, datasets:[{label:'Ø Trefferquote %', data: pick(agg.avgAcc)}] },
          options:{ responsive:true, maintainAspectRatio:false, plugins:{legend:{display:false}}, scales:{y:{beginAtZero:true,max:100}} }
        });
        gaExt = new Chart(c5, { type:'bar',
          data:{ labels:players, datasets:[{label:'Max. Stiche', data: pick(agg.maxT)},{label:'Max. Abweichung', data: pick(agg.maxD)}] },
          options:{ responsive:true, maintainAspectRatio:false }
        });
      },

      restart(){ Storage.clear(); location.reload(); }
    };

    /* ---------- Game flow with centered warnings ---------- */
    const Game = {
      buf:'',
      d(x){ if(this.buf.length<2){ this.buf+=x; $('#numberDisplay').textContent=this.buf; } },
      cl(){ this.buf=''; $('#numberDisplay').textContent='0'; },
      ok(){
        const val=parseInt(this.buf||'0',10);
        const idx=(S.round+S.stepIndex)%S.players.length;
        const player=S.players[idx];

        // hard limits
        if(S.step==='prediction' && val>S.round){
          const m=`❌ In Runde ${S.round} darf niemand mehr als ${S.round} tippen.`;
          $('#inputError').textContent=m; UI.toast(m); this.cl(); return;
        }

        if(S.step==='prediction'){
          if(!S.predictions[S.round-1]) S.predictions[S.round-1]={};
          S.predictions[S.round-1][player]=val;
          S.history.push({type:'pred', r:S.round-1, player, value:val});

          const P=S.predictions[S.round-1];
          const sum=Object.values(P).reduce((a,b)=>a+b,0);
          const total=S.round;
          const isLast=(S.stepIndex===S.players.length-1);
          $('#inputError').textContent='';

          if(S.mode==='plusminus' && isLast && sum===total){
            delete P[player]; S.history.pop();
            const m='❌ Summe darf nicht den möglichen Stichen entsprechen.';
            $('#inputError').textContent=m; UI.toast(m);
            this.cl(); UI.top(); UI.tables(); Storage.save(); return;
          }
          if(S.mode==='leaderOnly' && isLast){
            const top=Math.max(...Object.values(S.scores));
            const leaders=S.players.filter(p=>S.scores[p]===top);
            if(leaders.length===1 && leaders[0]===player && sum===total){
              delete P[player]; S.history.pop();
              const m='❌ Führender darf die Summe nicht „even“ machen.';
              $('#inputError').textContent=m; UI.toast(m);
              this.cl(); UI.top(); UI.tables(); Storage.save(); return;
            }
          }
          S.stepIndex++;
          if(S.stepIndex>=S.players.length){ S.step='result'; S.stepIndex=0; }
        } else {
          if(!S.results[S.round-1]) S.results[S.round-1]={};
          const R=S.results[S.round-1];
          const partial=Object.values(R).reduce((a,b)=>a+(b||0),0);
          const remain=S.round - partial;

          if(val>remain){
            const m=`❌ Zu hoch: Verbleibend ${remain}, eingegeben ${val}. Reihe wird neu gestartet.`;
            $('#inputError').textContent=m; UI.toast(m);
            S.results[S.round-1]={}; S.step='result'; S.stepIndex=0;
            this.cl(); recalcScores(); UI.top(); UI.tables(); Storage.save();
            return;
          }

          const isLast=(S.stepIndex===S.players.length-1);
          if(isLast && val!==remain){
            const m=`❌ Letzter Eintrag muss ${remain} sein. Reihe wird neu gestartet.`;
            $('#inputError').textContent=m; UI.toast(m);
            S.results[S.round-1]={}; S.step='result'; S.stepIndex=0;
            this.cl(); recalcScores(); UI.top(); UI.tables(); Storage.save();
            return;
          }

          R[player]=val;
          S.history.push({type:'res', r:S.round-1, player, value:val});

          S.stepIndex++;
          if(S.stepIndex>=S.players.length){
            S.round++; S.step='prediction'; S.stepIndex=0;
          }
        }

        this.cl(); recalcScores(); UI.top(); UI.tables(); Storage.save();
        if(S.round>S.maxRounds && S.step==='prediction'){ Handlers.end(true); }
      }
    };

    /* ---------- Handlers ---------- */
    const Handlers = {
      start(){
        const players=[...document.querySelectorAll('#playerInputs input')].map(i=>i.value.trim()).filter(Boolean);
        if(players.length<2 || players.length>6){ $('#setupError').textContent='Bitte 2–6 Spieler angeben.'; return; }
        S.players=players;
        S.hiddenBids=$('#hiddenBids').checked;
        S.roundRule = $('#segRounds button.active')?.dataset.val || 'official';
        S.mode      = $('#segMode button.active')?.dataset.val || 'classic';
        if(S.roundRule==='custom'){
          S.customRounds={3:parseInt($('#r3').value||'20',10),4:parseInt($('#r4').value||'15',10),5:parseInt($('#r5').value||'12',10),6:parseInt($('#r6').value||'10',10)};
        }
        S.round=1; S.step='prediction'; S.stepIndex=0; S.predictions=[]; S.results=[]; S.history=[]; S.savedFinal=false;
        S.maxRounds=computeMaxRounds(); S.scores=Object.fromEntries(players.map(p=>[p,0]));
        recalcScores(); Storage.save(); showView('game'); UI.top(); UI.tables(); UI.updateCharts();
      },
      load(){
        if(Storage.load()){
          S.maxRounds=computeMaxRounds(); recalcScores(); showView('game'); UI.top(); UI.tables(); UI.updateCharts();
        }
      },
      reset(){ if(confirm('Wirklich alles zurücksetzen?')){ Storage.clear(); location.reload(); } },
      delPred(i){ if(!confirm(`Tipps in Runde ${i+1} löschen?`)) return;
        S.predictions[i]={}; S.results[i]={}; S.round=i+1; S.step='prediction'; S.stepIndex=0; S.history.push({type:'wipePred', r:i});
        recalcScores(); UI.top(); UI.tables(); Storage.save(); UI.updateCharts();
      },
      delRes(i){ if(!confirm(`Ergebnisse in Runde ${i+1} löschen?`)) return;
        S.results[i]={}; S.round=i+1; S.step='result'; S.stepIndex=0; S.history.push({type:'wipeRes', r:i});
        recalcScores(); UI.top(); UI.tables(); Storage.save(); UI.updateCharts();
      },
      redoRound(){
        const r = S.round-1;
        if(r<0) return;
        if(!confirm(`Runde ${S.round} neu eingeben?`)) return;
        S.predictions[r]={}; S.results[r]={}; S.step='prediction'; S.stepIndex=0;
        $('#inputError').textContent='';
        recalcScores(); UI.top(); UI.tables(); Storage.save(); UI.updateCharts();
      },
      end(auto=false){
        recalcScores(); UI.final(); $('#endView').classList.remove('hidden');
        UI.updateEndCharts();

        // Autosave end result once
        if(!S.savedFinal){ Saves.saveFinished(true); S.savedFinal=true; Storage.save(); }

        // Konfetti bei manuellem Ende
        if(!auto){
          const colors=['#6366f1','#38bdf8','#fbbf24','#34d399','#f472b6','#a5b4fc','#818cf8','#fca5a5','#bef264'];
          for(let i=0;i<64;i++){
            const d=document.createElement('div'); d.style.position='fixed'; d.style.zIndex=99999; d.style.pointerEvents='none';
            d.style.width=(8+Math.random()*8)+'px'; d.style.height=(14+Math.random()*16)+'px'; d.style.borderRadius='4px';
            d.style.left=(8+Math.random()*84)+'vw'; d.style.top='-80px'; d.style.opacity=.92; d.style.background = colors[Math.random()*colors.length|0];
            d.animate([{ transform:`translateY(-80px) rotate(0deg)`, opacity:1 },{ transform:`translateY(96vh) rotate(340deg)`, opacity:0 }], { duration:1200+Math.random()*800, easing:'cubic-bezier(.4,0,.4,1)', fill:'forwards' });
            document.body.appendChild(d); setTimeout(()=>d.remove(),2000);
          }
        }
      }
    };

    /* ---------- Swipe to close EndView (back to Start) ---------- */
    (function(){
      const el = document.getElementById('endView');
      let sx=0, sy=0, dx=0, dy=0, active=false;
      function start(e){ const t=(e.touches?e.touches[0]:e); sx=t.clientX; sy=t.clientY; dx=dy=0; active=true; }
      function move(e){ if(!active) return; const t=(e.touches?e.touches[0]:e); dx=t.clientX-sx; dy=t.clientY-sy; }
      function end(){ if(!active) return; active=false; if(Math.abs(dx)>80 && Math.abs(dx)>Math.abs(dy)){ el.classList.add('hidden'); showView('setup'); } }
      el.addEventListener('touchstart',start,{passive:true});
      el.addEventListener('touchmove',move,{passive:true});
      el.addEventListener('touchend',end);
      el.addEventListener('pointerdown',start);
      el.addEventListener('pointermove',move);
      el.addEventListener('pointerup',end);
    })();

    /* ---------- Boot ---------- */
    (function(){
      try{
        $('#year').textContent=new Date().getFullYear();
        UI.init();
        showView('setup');
        if(window.innerWidth<=900){ $('#sidebar').classList.remove('collapsed'); $('#content').classList.remove('shifted'); }
      } catch(e){
        console.error(e);
        alert('Init-Fehler: ' + (e?.message || e));
      }
    })();
  </script>
</body>
</html>
